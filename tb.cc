//////////////////////////////////////////////////////////////////////
// C++ source file generated by SCRC V2.2
// Design: tb
// File:   tb.cc
// Time:   Wed May  4 15:16:43 2016
//////////////////////////////////////////////////////////////////////

#include "tb.h"

// channel class definitions /////////////////////////////////////////

c_queue::c_queue(const unsigned long int (&size))
    : size(size),
    buffer(0),
    n(0ul),
    p(0ul),
    wr(0ul),
    ws(0ul)
{   /* nothing */
}

c_queue::~c_queue(void)
{   /* nothing */
}

#line 88 "/usr/local/specc/scrc-2.2/import/c_queue.sc"
void c_queue::cleanup(void)
{   
    if ( !n)
    {   
	free(buffer);
	buffer = 0;
    }
}

void c_queue::receive(void *d, unsigned long int l)
{   
    unsigned long int p0;

    while(l > n)
    {   
	wr++ ;
	_specc::wait(event(&r), ((void*)0));
	wr-- ;
    }

    if (n <= p)
    {   
	p0 = p - n;
    }
    else 
    {   
	p0 = p + size - n;
    }
    if (l <= size - p0)
    {   
	memcpy(d,  &buffer[p0], l);
	n -= l;
    }
    else 
    {   
	memcpy(d,  &buffer[p0], size - p0);
	memcpy(((char *)d) + (size - p0),  &buffer[0], l - (size - p0));
	n -= l;
    }

    if (ws)
    {   
	_specc::notify(event(&s), ((void*)0));
    }

    cleanup();
}

void c_queue::send(const void *d, unsigned long int l)
{   
    while(l > size - n)
    {   
	ws++ ;
	_specc::wait(event(&s), ((void*)0));
	ws-- ;
    }

    setup();

    if (l <= size - p)
    {   
	memcpy( &buffer[p], d, l);
	p += l;
	n += l;
    }
    else 
    {   
	memcpy( &buffer[p], d, size - p);
	memcpy( &buffer[0], ((char *)d) + (size - p), l - (size - p));
	p = l - (size - p);
	n += l;
    }

    if (wr)
    {   
	_specc::notify(event(&r), ((void*)0));
    }
}

#line 76 "/usr/local/specc/scrc-2.2/import/c_queue.sc"
void c_queue::setup(void)
{   
    if ( !buffer)
    {   
	if ( !(buffer = (char *)malloc(size)))
	{   
	    fputs("c_queue: out of memory\n", stderr);
	    exit(1);
	}
    }
}

// behavior class definitions ////////////////////////////////////////

#line 122 "tb.cc"
ground_station::ground_station(i_tranceiver (&bluetooth))
    : bluetooth(bluetooth)
{   /* nothing */
}

ground_station::~ground_station(void)
{   /* nothing */
}

#line 17 "./ground_station.sc"
void ground_station::main(void) {
    unsigned int pitch; unsigned int roll; unsigned int throttle; unsigned int yaw;
    printf("starting ground station\n", throttle, pitch, roll, yaw);
    while(1)
    {   

	bluetooth.receive( &throttle, sizeof (throttle));

	bluetooth.receive( &pitch, sizeof (pitch));

	bluetooth.receive( &roll, sizeof (roll));

	bluetooth.receive( &yaw, sizeof (yaw));

	printf("throttle:\t%d\npitch:\t%d\nroll:\t%d\nyaw:\t%d\n\n", throttle, pitch, roll, yaw);
	fflush(stdout);
    }
}

#line 152 "tb.cc"
quadcopter::quadcopter(i_receiver (&rc), i_tranceiver (&bluetooth))
    : rc(rc), bluetooth(bluetooth),
    MAX_SIZE(256ul),
    accel_channel(MAX_SIZE),
    accel_unit(accel_channel),
    gps_channel(MAX_SIZE),
    gps_unit(gps_channel),
    gyro_channel(MAX_SIZE),
    gyro_unit(gyro_channel),
    lidar_channel(MAX_SIZE),
    lidar_unit(lidar_channel)
{   /* nothing */
}

quadcopter::~quadcopter(void)
{   /* nothing */
}

#line 37 "./quadcopter.sc"
void quadcopter::main(void) {


    { _specc::fork _scc_fork_0(&accel_unit), _scc_fork_1(&gyro_unit), _scc_fork_2(&lidar_unit), _scc_fork_3(&gps_unit); _specc::par(
	    &_scc_fork_0, 
	    &_scc_fork_1, 
	    &_scc_fork_2, 
	    &_scc_fork_3, ((_specc::fork*)0));
    }


    while(1)
    {   



	rc.receive( &throttle, sizeof (throttle));

	rc.receive( &pitch, sizeof (pitch));

	rc.receive( &roll, sizeof (roll));

	rc.receive( &yaw, sizeof (yaw));

#line 76 "./quadcopter.sc"
	waiting_time = waiting_time + ((double)135 / 100);




	waiting_time = waiting_time + ((double)135 / 100);




	waiting_time = waiting_time + ((double)63 / 100);




	waiting_time = waiting_time + ((double)99 / 100);

#line 107 "./quadcopter.sc"
	bluetooth.send( &throttle, sizeof (throttle));



	waiting_time = waiting_time + (((double)80 / 9600) * 1.000000000000000e+03);


	bluetooth.send( &pitch, sizeof (pitch));

	waiting_time = waiting_time + (((double)80 / 9600) * 1.000000000000000e+03);


	bluetooth.send( &roll, sizeof (roll));

	waiting_time = waiting_time + (((double)80 / 9600) * 1.000000000000000e+03);


	bluetooth.send( &yaw, sizeof (yaw));

	waiting_time = waiting_time + (((double)80 / 9600) * 1.000000000000000e+03);

	_specc::waitfor((10));
    }
}

#line 240 "tb.cc"
rc_transmitter::rc_transmitter(i_sender (&rc))
    : rc(rc)
{   /* nothing */
}

rc_transmitter::~rc_transmitter(void)
{   /* nothing */
}

#line 16 "./rc_transmitter.sc"
void rc_transmitter::main(void) {
    unsigned int pitch = 1000u; unsigned int roll = 1000u; unsigned int throttle = 1000u; unsigned int yaw = 1000u;
    while(1)
    {   


	rc.send( &throttle, sizeof (throttle));

	rc.send( &pitch, sizeof (pitch));

	rc.send( &roll, sizeof (roll));

	rc.send( &yaw, sizeof (yaw));
	throttle += 1;
	if (throttle > 2000) throttle = 2000;
	_specc::waitfor((1));
    }
}

#line 270 "tb.cc"
accelerometer::accelerometer(i_sender (&communication))
    : communication(communication)
{   /* nothing */
}

accelerometer::~accelerometer(void)
{   /* nothing */
}

#line 14 "./sensors.sc"
void accelerometer::main(void) {
    double data = 0.000000000000000e+00;
    while(1)
    {   
    }
}

#line 288 "tb.cc"
gyroscope::gyroscope(i_sender (&communication))
    : communication(communication)
{   /* nothing */
}

gyroscope::~gyroscope(void)
{   /* nothing */
}

#line 27 "./sensors.sc"
void gyroscope::main(void) {
    double data = 0.000000000000000e+00;
    while(1)
    {   
    }
}

#line 306 "tb.cc"
lidar::lidar(i_sender (&communication))
    : communication(communication)
{   /* nothing */
}

lidar::~lidar(void)
{   /* nothing */
}

#line 40 "./sensors.sc"
void lidar::main(void) {
    double data = 0.000000000000000e+00;
    while(1)
    {   
    }
}

#line 324 "tb.cc"
gps::gps(i_sender (&communication))
    : communication(communication)
{   /* nothing */
}

gps::~gps(void)
{   /* nothing */
}

#line 53 "./sensors.sc"
void gps::main(void) {
    double data = 0.000000000000000e+00;
    while(1)
    {   
    }
}

#line 342 "tb.cc"
Main::Main(void)
    : MAX_SIZE(256ul),
    U0(rc),
    U1(bluetooth),
    U2(rc, bluetooth),
    bluetooth(MAX_SIZE),
    rc(MAX_SIZE)
{   /* nothing */
}

Main::~Main(void)
{   /* nothing */
}

#line 27 "tb.sc"
int Main::main(void)
{   
    printf("kksdjfl\n");
    { _specc::fork _scc_fork_0(&U0), _scc_fork_1(&U1), _scc_fork_2(&U2); _specc::par(
	    &_scc_fork_0, 
	    &_scc_fork_1, 
	    &_scc_fork_2, ((_specc::fork*)0));
    }

    return 0;
}

#line 370 "tb.cc"
Main _scc_main;

int main(void)
{   
    int _scc_main_return;
    
    _specc::start();
    _scc_main_return = _scc_main.main();
    _specc::end();
    return(_scc_main_return);
}

//////////////////////////////////////////////////////////////////////
// End of file tb.cc
//////////////////////////////////////////////////////////////////////
